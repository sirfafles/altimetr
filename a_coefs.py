import numpy as np

# Данные
x = np.array([52426.58, 44900.83, 36764.06, 22007.56, 57554.30,
              54592.53, 51441.00, 47913.65, 44190.13, 40108.35, 34988.15])
h_swh = np.array([0.062, 0.056, 0.042, 0.093, 0.097, 
                  0.117, 0.083, 0.192, 0.192, 0.145, 0.125])

U10 = 5.0  # м/с
g = 9.81

    # Начальные приближения коэффициентов
a1, a2 = 0.01, 0.01
eps = 1e-6  # точность
max_iter = 1000

def F_model(a1, a2, U10, x):
    return a1 * (U10**2 / g) * (g*x / U10**2) ** (-a2)

for iteration in range(max_iter):
    # Вычисляем модель и остатки
    F = F_model(a1, a2, U10, x)
    L = F - h_swh

    # Частные производные
    dF_da1 = (U10**2 / g) * (g*x / U10**2) ** (-a2)
    dF_da2 = -a1 * (U10**2 / g) * (g*x / U10**2) ** (-a2) * np.log(g*x / U10**2)

    # Формируем матрицу B
    B = np.column_stack((dF_da1, dF_da2))

    # Решаем линейную систему для delta a
    delta_a = np.linalg.inv(B.T @ B) @ B.T @ L

    # Обновляем коэффициенты
    a1 -= delta_a[0]
    a2 -= delta_a[1]

    # Проверка сходимости
    if np.linalg.norm(delta_a) < eps:
        break

print(f"Итоговые коэффициенты: a1 = {a1:.4f}, a2 = {a2:.4f}")
